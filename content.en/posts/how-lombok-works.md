+++
author = "Parth Mudgal"
title = "Lombok notes"
date = "2023-06-11"
draft = false
description = "How lombok works"
tags = [
    "maven",
    "java",
    "lombok",
    "annotation processing"
]
+++

# How lombok works

- Lombok uses ant to build the repository into a jar
- Uses SCL to hides classes not useful for the developer
- Compile time annotation processing
- Modfying the java AST in-place
- Bytecode rewriting

## Shadow Class Loader (SCL)

Lombok renames most `.class` files to `.SCL.lombok` using an ant step called `mappedresources` when it builds the jar. The shadow classloader serves to completely hide almost all classes in a given jar file by using a different file ending

From the lombok SCL class documentation,  Using ShadowClassLoader accomplishes the following things:
- Avoid contaminating the namespace of any project using an SCL-based jar. Autocompleters in IDEs will NOT suggest anything other than actual public API.
- Like jarjar, allows folding in dependencies such as ASM without foisting these dependencies on projects that use this jar. shadowloader obviates the need for jarjar.
- Allows an agent (which MUST be in jar form) to still load everything except this loader infrastructure from class files generated by the IDE, which should
  considerably help debugging, as you can now rely on the IDE's built-in auto-recompile features instead of having to run a full build everytime, and it should help
  with hot code replace and the like (this is what the {@code shadow.override} feature is for).

### Assembling of the jar with SCL

"mappedresources" does not have a direct equivivelent in maven plugins so I [build one](https://github.com/unloggedio/rename-file-maven-plugin) to be used for unlogged-sdk since I did not intend to use ant for the build process. This maven plugin will rename files based on regex just before the final jar is being assembled. This is how the usage looks like

```xml
<plugin>
    <groupId>video.bug</groupId>
    <artifactId>rename-file-maven-plugin</artifactId>
    <version>1.0-SNAPSHOT</version>
    <executions>
        <execution>
            <phase>compile</phase>
            <goals>
                <goal>rename-file</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <source>(.+).class</source>
        <target>$1.scl.unlogged</target>
        <workingDirectory>${build.directory}/classes/io/unlogged/processor</workingDirectory>
    </configuration>
</plugin>
```

### Using the SCL

ClassLoaders is an abstract class in java which the JVM relies on to load the byte codes for any class. The purpose of the ClassLoader is to provide the class byte code to the JVM on request. You can read about class loaders [here](https://www.baeldung.com/java-classloaders)


#### Java agent
A java-agent implements the class transformer "ClassFileTransformer" interface. In this approach the JVM loads the ClassTransformar instance entering through the "premain" method, which receives an instance of an Instrumentation object. You can read more about java-agent and the Instrumentation object [here](https://www.baeldung.com/java-instrumentation)

#### ClassLoader injection
The other approach is to explicitely load a class using your custom loader. The important part is that if ClassA dependends on ClassB and ClassB is not already loaded, then the JVM will request the class loader of ClassA to load ClassB. And this is lombok brings SCL to life. The entry class `AnnotationProcessorHider` creates an instance of the AnnotationProcesser by asking the ShadowClassLoader to load it.



## Annotation Processing (APT)

From [Java Annotation Processing (defined by JSR 269)](https://jcp.org/en/jsr/detail?id=269): 

```
J2SE 1.5 added a new Java language mechanism "annotations" that allows annotation types to be used to 
annotate classes, fields, and methods. These annotations are typically processed either by build-time 
tools or by run-time libraries to achieve new semantic effects. In order to support annotation 
processing at build-time, this JSR will define APIs to allow annotation processors to be created 
using a standard pluggable API. This will simplify the task of creating annotation processors and will 
also allow automation of the discovery of appropriate annotation processors for a given source file.
```

The java compilation process happens in multiple "Rounds". In each round the java compiler might discover a new set of unprocessed files and will query each annotation process if it wants to process or not. The query itself is based on another Annotation called `@SupportedAnnotationTypes` which you annotate your AnnotationProcessor with. `@SupportedAnnotationTypes` indicates what type of annotations can the AnnotationProcessor process. We can also give it a "\*" to want to process all annotations (including un-annotated classes)

### Discovery of annotation processors

Javac discovers annotation processors based on its own service discovery protocol. This is very different from the web based/micro service discovery where you make an API call to locate the service endpoint. You can read more about [ServiceProviders here](https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html) and [here](https://stackoverflow.com/questions/4544899/java-meta-inf-services) and [here](https://www.baeldung.com/java-spi). 

AnnotationProcessors primarily implement two methods, `init()` and `process()`. The first method, `init()` is called when the AnnotationProcessor is initialized and it receives an instance of `ProcessingEnvironment` as an argument. The second method, `process()`, is called for every round the java compiler finds a new set of files eligible to be processed (based on the supported annotation types earlier)

Lombok defines two annotation processors in its jar

```
lombok.launch.AnnotationProcessorHider$AnnotationProcessor
lombok.launch.AnnotationProcessorHider$ClaimingProcessor
```

The requirement of two Processors isn't clear, especially given that the second one, `ClaimingProcessor` doesn't do anything, it just returns `true` signaling the compiler that this set of annotations has been processed now. But thanks to a comment available inside the process method of the main AnnotationProcessor we get a hint of whats going on.

```java
// Normally we rely on the claiming processor to claim away all lombok annotations.
// One of the many Java9 oversights is that this 'process' API has not been fixed to address the point that 'files I want to look at' and 'annotations I want to claim' must be one and the same,
// and yet in java9 you can no longer have 2 providers for the same service, thus, if you go by module path, lombok no longer loads the ClaimingProcessor.
// This doesn't do as good a job, but it'll have to do. The only way to go from here, I think, is either 2 modules, or use reflection hackery to add ClaimingProcessor during our init.
```


### Limitation of Annotation Processing

The major limitation is that AnnotationProcessor cannot make changes to existing files. It can only create new files or bytecode. And since this is about lombok, this limitation is absolute conflict with what lombok wants to do, that is, add methods to existing classes based on annotations. This is what we are going to cover.



## Hooking into the java build

At this point I am assuming you have a JAR of lombok on your class path and we are going to look inside the compilation phase. To hook into the java compilation phase using your debugger, you wan to run the build process with remote debugging enabled. To do this

- Maven

```bash
MAVEN_OPTS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 " mvn clean package 
```


- Gradle

```bash
GRADLE_OPTS='-Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005'  ./gradlew clean build
```


With the above parameters, the build process will pause (suspend=y) and server the remote debug server (server=y) at the port 5005. Now the debugger can connect to it. In IntellJ you can do this by creating a new Debug Profile of type "Remote JVM Debug". Make sure the port number matches in your intellij debug config and the one you have used to start the process. Once you have created that, click the debug button and you will be inside the javac compilation process in debug mode. Remember to put a breakpoint in the entry point of the annotation processor which is the `init()` method



## Patching and Hacking the Java Compilation

One thing to keep in mind from this point onwards is that there are many java compilers and lombok needs to work out with all of them (so does our sdk). So we are going to encounter all kinds of patching

### disableJava9SillyWarning


The first thing which lombok annotation processor tries to do is [disable warnings related to unsafe access](https://github.com/projectlombok/lombok/blob/000ce6d19a3d4a7d8c88ffa51e47ffda2a3b2c79/src/launch/lombok/launch/AnnotationProcessor.java#L71) of internal fields. We can read into the minor annoyance about it from the lombok developer thanks to the comment inside that method

```java
// JVM9 complains about using reflection to access packages from a module that aren't exported. This makes no sense; the whole point of reflection
// is to get past such issues. The only comment from the jigsaw team lead on this was some unspecified mumbling about security which makes no sense,
// as the SecurityManager is invoked to check such things. Therefore this warning is a bug, so we shall patch java to fix it.
```

You might have come across the ```--add-opens``` and ```--add-exports```  arguments when running with certain libraries/java-agents which allows module A to access module B via reflection. This access was allowed to begin with, until java 1.9 when warnings/limitations were added for such access. You can read more about it in this very succinct [answer on stackoverflow](https://stackoverflow.com/questions/44056405/whats-the-difference-between-add-exports-and-add-opens-in-java-9). The `disableJava9SillyWarning` method does not really enable it, but actually just suppresses the warning that come from doing such access.


### ProcessorDescriptor (Delegator pattern)

Immediatly into the annotation processor we are encountered with the delegator pattern (or correct me if I am wrong). We see two real implementation of `ProcessorDescriptor`. The `ProcessorDescriptor` interface has two methods. The first method `want()`, invoked by the `init()` of the entry point AnnotationProcessorHider declares whether it wantes to be involved the this compilation process or not. If `want()` returns false, then it would not be invoked by the `process()` method.

Since there are only two implementations, `EcjDescriptor` and `JavacDescriptor`, we can dive into both. The `want()` method is more of a `init()` on conditions method. The initializations wont happen if the condition is false. The only conditional difference between the two implementations is 

```java
procEnv.getClass().getName().startsWith("org.eclipse.jdt.")
```

which is to determine if the compilation by eclipse IDE or not. This part of the code was recently changed to do nothing. But we can once again thank the developer for the comment

```java
// Lombok used to work as annotation processor to ecj but that never actually worked properly, so we disabled the feature in 0.10.0.
// Because loading lombok as an agent in any ECJ-based non-interactive tool works just fine, we're not going to generate any warnings, as we'll
// likely generate more false positives than be helpful.

```












