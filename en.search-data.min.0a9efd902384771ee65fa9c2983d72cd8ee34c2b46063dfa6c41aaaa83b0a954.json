[{"id":0,"href":"/posts/how-lombok-works/","title":"Lombok notes","section":"Blog","content":" How lombok works # Lombok uses ant to build the repository into a jar Uses SCL to hides classes not useful for the developer Compile time annotation processing Modfying the java AST in-place Bytecode rewriting Shadow Class Loader (SCL) # Lombok renames most .class files to .SCL.lombok using an ant step called mappedresources when it builds the jar. The shadow classloader serves to completely hide almost all classes in a given jar file by using a different file ending\nFrom the lombok SCL class documentation, Using ShadowClassLoader accomplishes the following things:\nAvoid contaminating the namespace of any project using an SCL-based jar. Autocompleters in IDEs will NOT suggest anything other than actual public API. Like jarjar, allows folding in dependencies such as ASM without foisting these dependencies on projects that use this jar. shadowloader obviates the need for jarjar. Allows an agent (which MUST be in jar form) to still load everything except this loader infrastructure from class files generated by the IDE, which should considerably help debugging, as you can now rely on the IDE\u0026rsquo;s built-in auto-recompile features instead of having to run a full build everytime, and it should help with hot code replace and the like (this is what the {@code shadow.override} feature is for). Assembling of the jar with SCL # \u0026ldquo;mappedresources\u0026rdquo; does not have a direct equivivelent in maven plugins so I build one to be used for unlogged-sdk since I did not intend to use ant for the build process. This maven plugin will rename files based on regex just before the final jar is being assembled. This is how the usage looks like\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;video.bug\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rename-file-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;compile\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;rename-file\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;(.+).class\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;$1.scl.unlogged\u0026lt;/target\u0026gt; \u0026lt;workingDirectory\u0026gt;${build.directory}/classes/io/unlogged/processor\u0026lt;/workingDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; Using the SCL # ClassLoaders is an abstract class in java which the JVM relies on to load the byte codes for any class. The purpose of the ClassLoader is to provide the class byte code to the JVM on request. You can read about class loaders here\nJava agent # A java-agent implements the class transformer \u0026ldquo;ClassFileTransformer\u0026rdquo; interface. In this approach the JVM loads the ClassTransformar instance entering through the \u0026ldquo;premain\u0026rdquo; method, which receives an instance of an Instrumentation object. You can read more about java-agent and the Instrumentation object here\nClassLoader injection # The other approach is to explicitely load a class using your custom loader. The important part is that if ClassA dependends on ClassB and ClassB is not already loaded, then the JVM will request the class loader of ClassA to load ClassB. And this is lombok brings SCL to life. The entry class AnnotationProcessorHider creates an instance of the AnnotationProcesser by asking the ShadowClassLoader to load it.\nAnnotation Processing (APT) # From Java Annotation Processing (defined by JSR 269):\nJ2SE 1.5 added a new Java language mechanism \u0026#34;annotations\u0026#34; that allows annotation types to be used to annotate classes, fields, and methods. These annotations are typically processed either by build-time tools or by run-time libraries to achieve new semantic effects. In order to support annotation processing at build-time, this JSR will define APIs to allow annotation processors to be created using a standard pluggable API. This will simplify the task of creating annotation processors and will also allow automation of the discovery of appropriate annotation processors for a given source file. The java compilation process happens in multiple \u0026ldquo;Rounds\u0026rdquo;. In each round the java compiler might discover a new set of unprocessed files and will query each annotation process if it wants to process or not. The query itself is based on another Annotation called @SupportedAnnotationTypes which you annotate your AnnotationProcessor with. @SupportedAnnotationTypes indicates what type of annotations can the AnnotationProcessor process. We can also give it a \u0026ldquo;*\u0026rdquo; to want to process all annotations (including un-annotated classes)\nDiscovery of annotation processors # Javac discovers annotation processors based on its own service discovery protocol. This is very different from the web based/micro service discovery where you make an API call to locate the service endpoint. You can read more about ServiceProviders here and here and here.\nAnnotationProcessors primarily implement two methods, init() and process(). The first method, init() is called when the AnnotationProcessor is initialized and it receives an instance of ProcessingEnvironment as an argument. The second method, process(), is called for every round the java compiler finds a new set of files eligible to be processed (based on the supported annotation types earlier)\nLombok defines two annotation processors in its jar\nlombok.launch.AnnotationProcessorHider$AnnotationProcessor lombok.launch.AnnotationProcessorHider$ClaimingProcessor The requirement of two Processors isn\u0026rsquo;t clear, especially given that the second one, ClaimingProcessor doesn\u0026rsquo;t do anything, it just returns true signaling the compiler that this set of annotations has been processed now. But thanks to a comment available inside the process method of the main AnnotationProcessor we get a hint of whats going on.\n// Normally we rely on the claiming processor to claim away all lombok annotations. // One of the many Java9 oversights is that this \u0026#39;process\u0026#39; API has not been fixed to address the point that \u0026#39;files I want to look at\u0026#39; and \u0026#39;annotations I want to claim\u0026#39; must be one and the same, // and yet in java9 you can no longer have 2 providers for the same service, thus, if you go by module path, lombok no longer loads the ClaimingProcessor. // This doesn\u0026#39;t do as good a job, but it\u0026#39;ll have to do. The only way to go from here, I think, is either 2 modules, or use reflection hackery to add ClaimingProcessor during our init. Limitation of Annotation Processing # The major limitation is that AnnotationProcessor cannot make changes to existing files. It can only create new files or bytecode. And since this is about lombok, this limitation is absolute conflict with what lombok wants to do, that is, add methods to existing classes based on annotations. This is what we are going to cover.\nHooking into the java build # At this point I am assuming you have a JAR of lombok on your class path and we are going to look inside the compilation phase. To hook into the java compilation phase using your debugger, you wan to run the build process with remote debugging enabled. To do this\nMaven MAVEN_OPTS=\u0026#34;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 \u0026#34; mvn clean package Gradle GRADLE_OPTS=\u0026#39;-Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005\u0026#39; ./gradlew clean build With the above parameters, the build process will pause (suspend=y) and server the remote debug server (server=y) at the port 5005. Now the debugger can connect to it. In IntellJ you can do this by creating a new Debug Profile of type \u0026ldquo;Remote JVM Debug\u0026rdquo;. Make sure the port number matches in your intellij debug config and the one you have used to start the process. Once you have created that, click the debug button and you will be inside the javac compilation process in debug mode. Remember to put a breakpoint in the entry point of the annotation processor which is the init() method\nPatching and Hacking the Java Compilation # One thing to keep in mind from this point onwards is that there are many java compilers and lombok needs to work out with all of them (so does our sdk). So we are going to encounter all kinds of patching\ndisableJava9SillyWarning # The first thing which lombok annotation processor tries to do is disable warnings related to unsafe access of internal fields. We can read into the minor annoyance about it from the lombok developer thanks to the comment inside that method\n// JVM9 complains about using reflection to access packages from a module that aren\u0026#39;t exported. This makes no sense; the whole point of reflection // is to get past such issues. The only comment from the jigsaw team lead on this was some unspecified mumbling about security which makes no sense, // as the SecurityManager is invoked to check such things. Therefore this warning is a bug, so we shall patch java to fix it. You might have come across the --add-opens and --add-exports arguments when running with certain libraries/java-agents which allows module A to access module B via reflection. This access was allowed to begin with, until java 1.9 when warnings/limitations were added for such access. You can read more about it in this very succinct answer on stackoverflow. The disableJava9SillyWarning method does not really enable it, but actually just suppresses the warning that come from doing such access.\nProcessorDescriptor (Delegator pattern) # Immediatly into the annotation processor we are encountered with the delegator pattern (or correct me if I am wrong). We see two real implementation of ProcessorDescriptor. The ProcessorDescriptor interface has two methods. The first method want(), invoked by the init() of the entry point AnnotationProcessorHider declares whether it wantes to be involved the this compilation process or not. If want() returns false, then it would not be invoked by the process() method.\nSince there are only two implementations, EcjDescriptor and JavacDescriptor, we can dive into both. The want() method is more of a init() on conditions method. The initializations wont happen if the condition is false. The only conditional difference between the two implementations is\nprocEnv.getClass().getName().startsWith(\u0026#34;org.eclipse.jdt.\u0026#34;) which is to determine if the compilation by eclipse IDE or not. This part of the code was recently changed to do nothing. But we can once again thank the developer for the comment\n// Lombok used to work as annotation processor to ecj but that never actually worked properly, so we disabled the feature in 0.10.0. // Because loading lombok as an agent in any ECJ-based non-interactive tool works just fine, we\u0026#39;re not going to generate any warnings, as we\u0026#39;ll // likely generate more false positives than be helpful. "}]