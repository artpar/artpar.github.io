[{"id":0,"href":"/posts/how-lombok-works/","title":"Lombok notes","section":"Blog","content":" How lombok works # Lombok uses ant to build the repository into a jar Uses SCL to hides classes not useful for the developer Compile time annotation processing Modfying the java AST in-place Bytecode rewriting Shadow Class Loader (SCL) # Lombok renames most \u0026ldquo;.class\u0026rdquo; files to \u0026ldquo;.SCL.lombok\u0026rdquo; using an ant step called \u0026ldquo;mappedresources\u0026rdquo; when it builds the jar. The shadow classloader serves to completely hide almost all classes in a given jar file by using a different file ending\nFrom the lombok SCL class documentation, Using ShadowClassLoader accomplishes the following things:\nAvoid contaminating the namespace of any project using an SCL-based jar. Autocompleters in IDEs will NOT suggest anything other than actual public API. Like jarjar, allows folding in dependencies such as ASM without foisting these dependencies on projects that use this jar. shadowloader obviates the need for jarjar. Allows an agent (which MUST be in jar form) to still load everything except this loader infrastructure from class files generated by the IDE, which should considerably help debugging, as you can now rely on the IDE\u0026rsquo;s built-in auto-recompile features instead of having to run a full build everytime, and it should help with hot code replace and the like (this is what the {@code shadow.override} feature is for). Assembling of the jar with SCL # \u0026ldquo;mappedresources\u0026rdquo; does not have a direct equivivelent in maven plugins so I build one to be used for unlogged-sdk. This maven plugin will rename files based on regex just before the final jar is being assembled. This is how the usage looks like\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;video.bug\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rename-file-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;compile\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;rename-file\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;(.+).class\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;$1.scl.unlogged\u0026lt;/target\u0026gt; \u0026lt;workingDirectory\u0026gt;${build.directory}/classes/io/unlogged/processor\u0026lt;/workingDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; Using the SCL # ClassLoaders is an abstract class in java which the JVM relies on to load the byte codes for any class. The purpose of the ClassLoader is to provide the class byte code to the JVM on request. You can read about class loaders here\nJava agent # A java-agent implements the class transformer \u0026ldquo;ClassFileTransformer\u0026rdquo; interface. In this approach the JVM loads the ClassTransformar instance entering through the \u0026ldquo;premain\u0026rdquo; method, which receives an instance of an Instrumentation object. You can read more about java-agent and the Instrumentation object here\nClassLoader injection # The other approach is to explicitely load a class using your custom loader. The important part is that if ClassA dependends on ClassB and ClassB is not already loaded, then the JVM will request the class loader of ClassA to load ClassB. And this is lombok brings SCL to life. The entry class AnnotationProcessorHider creates an instance of the AnnotationProcesser by asking the ShadowClassLoader to load it.\nAnnotation Processing (APT) # From Java Annotation Processing (defined by JSR 269):\nJ2SE 1.5 added a new Java language mechanism \u0026#34;annotations\u0026#34; that allows annotation types to be used to annotate classes, fields, and methods. These annotations are typically processed either by build-time tools or by run-time libraries to achieve new semantic effects. In order to support annotation processing at build-time, this JSR will define APIs to allow annotation processors to be created using a standard pluggable API. This will simplify the task of creating annotation processors and will also allow automation of the discovery of appropriate annotation processors for a given source file. The java compilation process happens in multiple \u0026ldquo;Rounds\u0026rdquo;. In each round the java compiler might discover a new set of unprocessed files and will query each annotation process if it wants to process or not. The query itself is based on another Annotation called @SupportedAnnotationTypes which you annotate your AnnotationProcessor with. @SupportedAnnotationTypes indicates what type of annotations can the AnnotationProcessor process. We can also give it a \u0026ldquo;*\u0026rdquo; to want to process all annotations (including un-annotated classes)\nDiscovery of annotation processors # Javac discovers annotation processors based on its own service discovery protocol. This is very different from the web based/micro service discovery where you make an API call to locate the service endpoint. You can read more about ServiceProviders here and here and here\nLombok defines two annotation processors in its jar\nlombok.launch.AnnotationProcessorHider$AnnotationProcessor lombok.launch.AnnotationProcessorHider$ClaimingProcessor The requirement of two Processors isn\u0026rsquo;t clear, especially given that the second one, ClaimingProcessor doesn\u0026rsquo;t do anything, it just returns true signaling the compiler that this set of annotations has been processed now. But thanks to a comment available inside the process method of the main AnnotationProcessor we get a hint of whats going on.\n// Normally we rely on the claiming processor to claim away all lombok annotations. // One of the many Java9 oversights is that this \u0026#39;process\u0026#39; API has not been fixed to address the point that \u0026#39;files I want to look at\u0026#39; and \u0026#39;annotations I want to claim\u0026#39; must be one and the same, // and yet in java9 you can no longer have 2 providers for the same service, thus, if you go by module path, lombok no longer loads the ClaimingProcessor. // This doesn\u0026#39;t do as good a job, but it\u0026#39;ll have to do. The only way to go from here, I think, is either 2 modules, or use reflection hackery to add ClaimingProcessor during our init. Limitation of Annotation Processing # The major limitation is that AnnotationProcessor cannot make changes to existing files. It can only create new files or bytecode. And since this is about lombok, this limitation is 100% in conflict with what lombok wants to do, that is, add methods to existing classes based on annotations. This is what we are going to cover.\nPatching and Hacking the Java Compilation # At this point I am assuming you have a JAR of lombok on your class path and we are going to look inside the compilation phase. To hook into the java compilation phase using your debugger, you wan to run the build process with remote debugging enabled. To do this\nfor maven\nMAVEN_OPTS=\u0026quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 \u0026quot; mvn clean package for gradle\nGRADLE_OPTS='-Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005' ./gradlew clean build\n"}]